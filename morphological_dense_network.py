# -*- coding: utf-8 -*-
"""Morphological Dense Network

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fuZl4NYQhEYA48qy5TOb4UCshSiaZaPJ
"""

import tensorflow as tf
import tensorflow.keras as keras
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import load_breast_cancer, make_blobs, make_moons
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.model_selection import train_test_split
from mlxtend.plotting import plot_decision_regions
from sklearn import preprocessing

class Dilation_Erosion(keras.layers.Layer):
    def __init__(self, units_dil=32, units_ero=32):
        super(Dilation_Erosion, self).__init__()
        self.units_dil = units_dil
        self.units_ero = units_ero

    def erosion(self,w,X):
        return tf.reduce_min(X+w,axis=1)

    def dilation(self,w,X):
        return tf.reduce_max(X+w,axis=1)

    def dilation_layer(self, sp, X):
        # para cada neuronio de dilatação, calcula a dilatação
        return tf.transpose(tf.stack([self.dilation(s,X) for s in sp],axis=0))

    def erosion_layer(self,sm, X):
        # para cada neuronio de erosão, calcula a erosão
        return tf.transpose(tf.stack([self.erosion(s,X) for s in sm],axis=0))

    def build(self, input_shape):

        self.sp = list()
        for i in range(self.units_dil):
            peso = self.add_weight(
                shape=(1, input_shape[-1]),
                initializer="random_normal",
                trainable=True,
            )
            self.sp.append(peso)

        self.sm = list()
        for i in range(self.units_ero):
            peso = self.add_weight(
                shape=(1, input_shape[-1]),
                initializer="random_normal",
                trainable=True,
            )
            self.sm.append(peso)

    def call(self, inputs):
        return tf.concat([self.dilation_layer(self.sp,inputs),self.erosion_layer(self.sm,inputs)],axis=1)

class MorphDense(BaseEstimator, ClassifierMixin):

    def __init__(self) -> None:
        super().__init__()
        self.encoder = preprocessing.LabelEncoder()

    def fit(self, X, y):
        self.encoder.fit(y)
        y = self.encoder.transform(y)
        self.N = X.shape[1]
        self.Nclasses = 1
        self.inputs = tf.keras.layers.Input(shape=(self.N,))
        morph_layer = Dilation_Erosion(units_dil=128, units_ero=128)
        morph_output = morph_layer(self.inputs)
        self.outputs = tf.keras.layers.Dense(self.Nclasses, activation='sigmoid')(morph_output)
        self.model = tf.keras.models.Model(inputs=self.inputs, outputs=self.outputs)
        self.model.compile(optimizer="Adam", loss=tf.keras.losses.BinaryCrossentropy(), metrics=["accuracy"])
        self.model.fit(X, y, epochs = 50)

    def predict(self, X):
        y = np.asarray(self.model.predict(X)) >= 0.5
        y = y.reshape(-1,)
        y = [int(a) for a in y]
        return self.encoder.inverse_transform(y)